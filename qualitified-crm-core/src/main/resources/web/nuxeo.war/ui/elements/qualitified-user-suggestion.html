<dom-module id="qualitified-user-suggestion">
    <template>
        <style>
            :host {
                display: block;
            }

            :host([hidden]) {
                display: none;
            }
        </style>
        <nuxeo-selectivity id="s2" operation="[[operation]]" label="[[label]]" min-chars="[[minChars]]"
                           frequency="[[frequency]]" multiple="[[multiple]]"
                           params="[[_computeParams(params.*, searchType, groupRestriction)]]" placeholder="[[placeholder]]"
                           error-message="[[errorMessage]]" readonly="[[readonly]]" value="{{value}}"
                           selected-items="{{selectedItems}}" selected-item="{{selectedItem}}" required="[[required]]"
                           invalid="[[invalid]]" selection-formatter="[[selectionFormatter]]" result-formatter="[[resultFormatter]]"
                           resolve-entry="[[resolveEntry]]" id-function="[[idFunction]]" query-results-filter="[[queryResultsFilter]]"
                           stay-open-on-select="[[stayOpenOnSelect]]">
        </nuxeo-selectivity>

    </template>
    <script>
        Polymer({
            is: 'qualitified-user-suggestion',
            behaviors: [
              Polymer.IronFormElementBehavior,Polymer.IronValidatableBehavior
            ],
            properties: {
                // USER_TYPE or GROUP_TYPE or USER_GROUP_TYPE
                searchType: {
                    type: String,
                    value: 'USER_GROUP_TYPE',
                },

                /**
                 * Group ID to narrow the user suggestions.
                 */
                groupRestriction: {
                    type: String,
                },

                /**
                 * Label.
                 */
                label: String,

                /**
                 * Operation to call for suggestions.
                 */
                operation: {
                    type: String,
                    value: 'UserGroup.Suggestion',
                },

                /**
                 * Parameters for the operation.
                 */
                params: Object,

                /**
                 * Selected value(s).
                 */
                value: {
                    type: String,
                    notify: true,
                },

                /**
                 * Set to `true` to allow multiple selection.
                 */
                multiple: {
                    type: Boolean,
                    value: false,
                },

                /**
                 * If true, the dropdown stays open after a selection is made.
                 */
                stayOpenOnSelect: {
                    type: Boolean,
                    value: false,
                },

                /**
                 * Set to `true` for read only mode.
                 */
                readonly: {
                    type: Boolean,
                    value: false,
                },

                /**
                 * Minimum number of chars to trigger the suggestions.
                 */
                minChars: {
                    type: Number,
                    value: 3,
                },

                /**
                 * Time in ms used to debounce requests.
                 */
                frequency: Number,

                /**
                 * Placeholder.
                 */
                placeholder: String,

                /**
                 * Error message to show when `invalid` is true.
                 */
                errorMessage: String,

                /**
                 * Selected items.
                 */
                selectedItems: {
                    type: Array,
                    notify: true,
                },

                /**
                 * Selected item.
                 */
                selectedItem: {
                    type: Object,
                    notify: true,
                },

                /**
                 * Formatter for a selected entry.
                 */
                selectionFormatter: {
                    type: Function,
                    value() {
                        return this._selectionFormatter.bind(this);
                    },
                },

                /**
                 * Formatter for suggested entries.
                 */
                resultFormatter: {
                    type: Function,
                    value() {
                        return this._resultFormatter.bind(this);
                    },
                },

                /**
                 * Function that transforms entries added to the element using the `value` property into objects.
                 */
                resolveEntry: {
                    type: Function,
                    value() {
                        return this._resolveEntry.bind(this);
                    },
                },

                /**
                 * Set to true to submit ids prefixed with "user:" or "group:".
                 */
                prefixed:Boolean,

                idFunction: {
                    type: Function,
                    value() {
                        return this._idFunction.bind(this);
                    },
                },

                /**
                 * Results filtering function (optional).
                 */
                queryResultsFilter: Function
            },
            /* Override method from Polymer.IronValidatableBehavior. */
            _getValidity() {
                return this.$.s2._getValidity();
            },

            _computeParams() {
                return Object.assign(
                    {},
                    {
                        searchType: this.searchType,
                        groupRestriction: this.groupRestriction,
                    },
                    this.params,
                );
            },

            _selectionFormatter(item) {
                let content;
                if (item) {
                    if (
                        item['entity-type'] === 'user' &&
                        item.properties &&
                        item.properties.firstName &&
                        item.properties.lastName
                    ) {
                        content = `${item.properties.firstName} ${item.properties.lastName}`;
                    } else if (item['entity-type'] === 'group') {
                        content = item.grouplabel ? item.grouplabel : item.groupname;
                    } else if (item.displayLabel) {
                        content = item.displayLabel;
                    } else {
                        content = item.id ? item.id : item;
                    }
                }
                return `<span class="preserve-white-space">${this.escapeHTML(content)}</span>`;
            },

            _resultFormatter: function (item) {
                if (item.type && (item.type === 'USER_TYPE' || item.type === 'GROUP_TYPE')) {
                    console.log(item);

                    return `<nuxeo-user-group-formatter entity='${this.escapeHTML(JSON.stringify(item))}'></nuxeo-user-group-formatter>`;
                }
                // fallback, if entities are not available
                return escapeHTML(item.displayLabel || item.title);
            },

            _resolveEntry: function (item) {
                if (item && item['entity-type']) {
                    return item;
                }
                return this.prefixed ? { id: item, displayLabel: item, prefixed_id: item } : { id: item, displayLabel: item };
            },

            _idFunction: function (item) {
                if (this.prefixed) {
                    return item.prefixed_id ? item.prefixed_id : `${item['entity-type']}:${item.id}`;
                }
                return item.id;
            },
            escapeHTML: function(markup) {
                const replaceMap = {
                    '\\': '&#92;',
                    '&': '&amp;',
                    '<': '&lt;',
                    '>': '&gt;',
                    '"': '&quot;',
                    '\'': '&#39;',
                    '/': '&#47;',
                };

                // Do not try to escape the markup if it's not a string
                if (typeof markup !== 'string') {
                    return markup;
                }

                return String(markup).replace(/[&<>"'/\\]/g, (match) => replaceMap[match]);
            }

        })
    </script>
</dom-module>